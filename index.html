<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Fly Navigation - Three.js</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="m-0 overflow-hidden bg-gray-800">
    <div id="instructions" class="absolute top-2.5 left-2.5 text-white font-sans bg-black bg-opacity-50 p-2.5 rounded">
        Click to start navigation<br/>
        WASD/Arrows: Move<br/>
        Shift: Speed Boost<br/>
        Mouse: Look<br/>
        ESC: Release Mouse
    </div>
    <div id="crosshair" class="absolute top-1/2 left-1/2 w-0.5 h-0.5 bg-white rounded-full transform -translate-x-1/2 -translate-y-1/2 pointer-events-none hidden"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- Configuration ---
        const config = {
            initialCameraDistance: 10,
            moveSpeed: { normal: 6.0, boost: 16.0 },
            mouseSensitivity: 0.002,
            verticalRotationLimit: Math.PI / 2 - 0.01
        };

        // --- Global Variables ---
        let scene, camera, renderer, pivot;
        let clock = new THREE.Clock();
        
        // State tracking
        const movementState = { forward: 0, right: 0, shift: false };
        let pitch = 0, yaw = 0, isPointerLocked = false;
        
        // DOM elements
        const elements = {
            crosshair: document.getElementById('crosshair'),
            instructions: document.getElementById('instructions')
        };
        
        // Reusable vectors
        const vec = {
            direction: new THREE.Vector3(),
            right: new THREE.Vector3(),
            move: new THREE.Vector3(),
            worldUp: new THREE.Vector3(0, 1, 0)
        };

        // --- Initialization ---
        function init() {
            setupScene();
            createObjects();
            setupEventListeners();
            animate();
        }
        
        function setupScene() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x353ebd);
            scene.fog = new THREE.Fog(0x87ceeb, 1, 200);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);
            
            // Camera
            camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            // Pivot Point
            pivot = new THREE.Object3D();
            pivot.position.set(0, 1.7, 0);
            scene.add(pivot);
            
            updateCameraPosition();
            
            // Lighting
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 5);
            scene.add(directionalLight);
        }
        
        function createObjects() {
            // Simple objects
            createMesh(new THREE.BoxGeometry(2, 2, 2), 0xff0000, [10, 1, 0]);
            createMesh(new THREE.SphereGeometry(1.5, 32, 16), 0x0000ff, [-8, 1.5, -5]);
            createMesh(new THREE.ConeGeometry(1.5, 3, 32), 0xffff00, [0, 1.5, -12]);
            
            // Giant objects
            createMesh(new THREE.BoxGeometry(20, 20, 20), 0x9370DB, [70, 10, -50]);
            
            const torus = createMesh(new THREE.TorusGeometry(15, 5, 16, 50), 0x00CED1, [-80, 20, -90]);
            torus.rotation.x = Math.PI / 2;
            
            createMesh(new THREE.CylinderGeometry(10, 10, 30, 32), 0xFF8C00, [30, 15, -120]);
            createMesh(new THREE.ConeGeometry(15, 30, 4), 0x32CD32, [-40, 15, -150]);
        }
        
        function createMesh(geometry, color, position) {
            const material = new THREE.MeshStandardMaterial({ color });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(...position);
            scene.add(mesh);
            return mesh;
        }
        
        function setupEventListeners() {
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            // Key handlers
            const keyActions = {
                'KeyW': () => movementState.forward = 1,
                'ArrowUp': () => movementState.forward = 1,
                'KeyS': () => movementState.forward = -1,
                'ArrowDown': () => movementState.forward = -1,
                'KeyA': () => movementState.right = -1,
                'ArrowLeft': () => movementState.right = -1,
                'KeyD': () => movementState.right = 1,
                'ArrowRight': () => movementState.right = 1,
                'ShiftLeft': () => movementState.shift = true,
                'ShiftRight': () => movementState.shift = true
            };
            
            document.addEventListener('keydown', (event) => {
                if (!isPointerLocked) return;
                const action = keyActions[event.code];
                if (action) action();
            });
            
            document.addEventListener('keyup', (event) => {
                if (event.code === 'KeyW' || event.code === 'ArrowUp') {
                    if (movementState.forward === 1) movementState.forward = 0;
                } else if (event.code === 'KeyS' || event.code === 'ArrowDown') {
                    if (movementState.forward === -1) movementState.forward = 0;
                } else if (event.code === 'KeyA' || event.code === 'ArrowLeft') {
                    if (movementState.right === -1) movementState.right = 0;
                } else if (event.code === 'KeyD' || event.code === 'ArrowRight') {
                    if (movementState.right === 1) movementState.right = 0;
                } else if (event.code === 'ShiftLeft' || event.code === 'ShiftRight') {
                    movementState.shift = false;
                }
            });
            
            document.addEventListener('mousemove', (event) => {
                if (!isPointerLocked) return;
                
                // Update rotations
                yaw -= (event.movementX || 0) * config.mouseSensitivity;
                pitch -= (event.movementY || 0) * config.mouseSensitivity;
                pitch = Math.max(-config.verticalRotationLimit, Math.min(config.verticalRotationLimit, pitch));
            });
            
            document.addEventListener('pointerlockchange', () => {
                isPointerLocked = document.pointerLockElement === renderer.domElement;
                elements.crosshair.style.display = isPointerLocked ? 'block' : 'none';
                elements.instructions.style.display = isPointerLocked ? 'none' : 'block';
                
                if (!isPointerLocked) {
                    movementState.forward = 0;
                    movementState.right = 0;
                    movementState.shift = false;
                }
            });
            
            document.addEventListener('pointerlockerror', () => {
                console.error('Pointer Lock failed.');
                isPointerLocked = false;
                elements.crosshair.style.display = 'none';
                elements.instructions.style.display = 'block';
            });
            
            renderer.domElement.addEventListener('click', () => {
                if (!isPointerLocked) renderer.domElement.requestPointerLock();
            });
        }
        
        function updateCameraPosition() {
            const offset = new THREE.Vector3(0, 0, config.initialCameraDistance);
            const quaternion = new THREE.Quaternion()
                .setFromAxisAngle(vec.worldUp, yaw)
                .multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), pitch));
            
            offset.applyQuaternion(quaternion);
            camera.position.copy(pivot.position).add(offset);
            camera.quaternion.copy(quaternion);
        }
        
        function update(deltaTime) {
            const speed = movementState.shift ? config.moveSpeed.boost : config.moveSpeed.normal;
            const moveDelta = speed * deltaTime;
            
            // Calculate movement vector
            vec.move.set(0, 0, 0);
            
            if (movementState.forward || movementState.right) {
                camera.getWorldDirection(vec.direction);
                vec.right.crossVectors(vec.worldUp, vec.direction).normalize();
                
                if (movementState.forward) vec.move.addScaledVector(vec.direction, movementState.forward);
                if (movementState.right) vec.move.addScaledVector(vec.right, -movementState.right);
                
                if (vec.move.lengthSq() > 0.001) vec.move.normalize();
                
                pivot.position.addScaledVector(vec.move, moveDelta);
            }
            
            updateCameraPosition();
        }
        
        function animate() {
            requestAnimationFrame(animate);
            if (isPointerLocked) update(clock.getDelta());
            renderer.render(scene, camera);
        }
        
        // --- Start ---
        init();
    </script>
</body>
</html>