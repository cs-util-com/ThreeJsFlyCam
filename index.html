<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Fly Navigation - Three.js</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #333; }
        canvas { display: block; }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 2px; /* crosshairSize constant */
            height: 2px; /* crosshairSize constant */
            background-color: white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none; /* Allows clicking through */
            display: none; /* Hidden until pointer lock */
        }
        #instructions {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: sans-serif;
            background-color: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div id="instructions">
        Click to start navigation<br/>
        WASD/Arrows: Move<br/>
        Shift: Speed Boost<br/>
        Mouse: Look<br/>
        ESC: Release Mouse
    </div>
    <div id="crosshair"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- Configuration Constants ---
        const initialCameraDistance = 10;   // meters
        const normalMoveSpeed = 1.0;      // meters/second
        const boostMoveSpeed = 5.0;       // meters/second
        const mouseSensitivity = 0.002;   // radians/pixel delta
        const crosshairSize = 2;        // pixels (Reflected in CSS)
        const verticalRotationLimit = Math.PI / 2 - 0.01; // Radians (~ +/- 89.9 deg)

        // --- Global Variables ---
        let scene, camera, renderer, pivot;
        let clock = new THREE.Clock();

        // Movement State
        const movementState = {
            forward: 0, // -1 for backward, 1 for forward
            right: 0,   // -1 for left, 1 for right
            shift: false
        };

        // Rotation State
        let pitch = 0; // Vertical angle (relative to horizontal)
        let yaw = 0;   // Horizontal angle (around world Y axis)
        let isPointerLocked = false;

        const crosshairElement = document.getElementById('crosshair');
        const instructionsElement = document.getElementById('instructions');

        // Temporary vectors for calculations
        const tempCameraDirection = new THREE.Vector3();
        const tempRightDirection = new THREE.Vector3();
        const tempMoveVector = new THREE.Vector3();
        const worldUp = new THREE.Vector3(0, 1, 0);

        // --- Initialization ---
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb); // Sky blue background
            scene.fog = new THREE.Fog(0x87ceeb, 50, 200);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            // Pivot Point (using Object3D for easier management)
            pivot = new THREE.Object3D();
            pivot.position.set(0, 1.7, 0); // Start slightly above ground
            scene.add(pivot);

            // Set initial camera position relative to pivot based on initial pitch/yaw
            updateCameraPosition(); // Will calculate initial position based on pitch=0, yaw=0
            camera.lookAt(pivot.position);

            // --- Scene Content ---
            // Ground Plane
            const groundGeo = new THREE.PlaneGeometry(500, 500);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x228B22, side: THREE.DoubleSide }); // Forest green
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            scene.add(ground);

            // Simple Shapes
            const boxGeo = new THREE.BoxGeometry(2, 2, 2);
            const sphereGeo = new THREE.SphereGeometry(1.5, 32, 16);
            const coneGeo = new THREE.ConeGeometry(1.5, 3, 32);

            const mat1 = new THREE.MeshStandardMaterial({ color: 0xff0000 }); // Red
            const mat2 = new THREE.MeshStandardMaterial({ color: 0x0000ff }); // Blue
            const mat3 = new THREE.MeshStandardMaterial({ color: 0xffff00 }); // Yellow

            const box = new THREE.Mesh(boxGeo, mat1);
            box.position.set(10, 1, 0);
            scene.add(box);

            const sphere = new THREE.Mesh(sphereGeo, mat2);
            sphere.position.set(-8, 1.5, -5);
            scene.add(sphere);

            const cone = new THREE.Mesh(coneGeo, mat3);
            cone.position.set(0, 1.5, -12);
            scene.add(cone);

            // --- Lighting ---
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 5);
            scene.add(directionalLight);

            // --- Event Listeners ---
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('pointerlockchange', onPointerLockChange);
            document.addEventListener('pointerlockerror', onPointerLockError);
            renderer.domElement.addEventListener('click', () => {
                if (!isPointerLocked) {
                    renderer.domElement.requestPointerLock();
                }
            });

            // Start Animation Loop
            animate();
        }

        // --- Event Handlers ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onKeyDown(event) {
            if (!isPointerLocked) return;
            switch (event.code) {
                case 'KeyW': case 'ArrowUp':    movementState.forward = 1; break;
                case 'KeyS': case 'ArrowDown':  movementState.forward = -1; break;
                case 'KeyA': case 'ArrowLeft':  movementState.right = -1; break;
                case 'KeyD': case 'ArrowRight': movementState.right = 1; break;
                case 'ShiftLeft': case 'ShiftRight': movementState.shift = true; break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': case 'ArrowUp':    if (movementState.forward === 1) movementState.forward = 0; break;
                case 'KeyS': case 'ArrowDown':  if (movementState.forward === -1) movementState.forward = 0; break;
                case 'KeyA': case 'ArrowLeft':  if (movementState.right === -1) movementState.right = 0; break;
                case 'KeyD': case 'ArrowRight': if (movementState.right === 1) movementState.right = 0; break;
                case 'ShiftLeft': case 'ShiftRight': movementState.shift = false; break;
            }
        }

        function onMouseMove(event) {
            if (!isPointerLocked) return;

            const deltaX = event.movementX || 0;
            const deltaY = event.movementY || 0;

            // Update Yaw (horizontal rotation)
            yaw -= deltaX * mouseSensitivity;

            // Update Pitch (vertical rotation) - Clamp vertical angle
            pitch -= deltaY * mouseSensitivity;
            pitch = Math.max(-verticalRotationLimit, Math.min(verticalRotationLimit, pitch));

            // We don't directly rotate the pivot anymore with mouse look.
            // Pivot position changes via movement, camera position/rotation calculated from pitch/yaw.
        }

        function onPointerLockChange() {
            if (document.pointerLockElement === renderer.domElement) {
                isPointerLocked = true;
                crosshairElement.style.display = 'block';
                instructionsElement.style.display = 'none';
            } else {
                isPointerLocked = false;
                crosshairElement.style.display = 'none';
                instructionsElement.style.display = 'block';
                // Reset movement when releasing lock to prevent runaway movement
                movementState.forward = 0;
                movementState.right = 0;
                movementState.shift = false;
            }
        }

        function onPointerLockError() {
            console.error('Pointer Lock failed.');
            isPointerLocked = false;
            crosshairElement.style.display = 'none';
            instructionsElement.style.display = 'block';
        }

        // --- Update Camera Position relative to Pivot ---
        function updateCameraPosition() {
            // Start with offset directly behind the pivot *along the negative Z axis in pivot space*
            const offset = new THREE.Vector3(0, 0, initialCameraDistance);

            // Create a quaternion representing the camera's orientation based on pitch and yaw
            // Apply yaw first (around world Y), then pitch (around camera's local X)
            const quaternion = new THREE.Quaternion();
            const yawQuaternion = new THREE.Quaternion().setFromAxisAngle(worldUp, yaw);
            const pitchQuaternion = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), pitch);

            // Combine rotations: apply pitch relative to the yawed orientation
            quaternion.multiplyQuaternions(yawQuaternion, pitchQuaternion);

            // Rotate the offset vector by the combined quaternion
            offset.applyQuaternion(quaternion);

            // Calculate final camera position by adding the rotated offset to the pivot position
            camera.position.copy(pivot.position).add(offset);

            // Set camera rotation using the same quaternion
            camera.quaternion.copy(quaternion);

             // Ensure camera looks forward along its orientation, not necessarily AT the pivot anymore
             // This allows the pivot to be the center of *movement* but not strictly the look-at target
             // camera.lookAt(pivot.position); // We remove this line
        }


        // --- Update Logic ---
        function update(deltaTime) {
            const currentSpeed = movementState.shift ? boostMoveSpeed : normalMoveSpeed;
            const moveDelta = currentSpeed * deltaTime;

            // --- Calculate Movement Directions ---
            // Forward/Backward based on Camera's actual direction
            camera.getWorldDirection(tempCameraDirection); // Gets the vector the camera is looking along

            // Right/Left based on a horizontal plane (using world Up and camera direction)
            // This ensures strafing is horizontal regardless of pitch
            tempRightDirection.crossVectors(worldUp, tempCameraDirection).normalize(); // Calculate right vector relative to world vertical

            // --- Calculate Final Movement Vector ---
            tempMoveVector.set(0, 0, 0); // Reset move vector

            // Add forward/backward component (use NEGATED camera direction)
            if (movementState.forward !== 0) {
                tempMoveVector.addScaledVector(tempCameraDirection, -movementState.forward); // Invert forward state
            }
            // Add right/left component
            if (movementState.right !== 0) {
                tempMoveVector.addScaledVector(tempRightDirection, -movementState.right); // Use calculated right vector, invert right state
            }

            // Normalize the final move vector ONLY if there's combined movement (diagonal)
            // to ensure consistent speed. Check magnitude squared for efficiency.
             if (tempMoveVector.lengthSq() > 0) { // Check if there is any movement input
                 tempMoveVector.normalize();
             }


            // --- Apply Movement ---
            pivot.position.addScaledVector(tempMoveVector, moveDelta);

            // Update camera position based on new pivot position and current pitch/yaw
            updateCameraPosition();
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            const deltaTime = clock.getDelta();

            if (isPointerLocked) {
                 update(deltaTime);
            }

            renderer.render(scene, camera);
        }

        // --- Start ---
        init();

    </script>
</body>
</html>