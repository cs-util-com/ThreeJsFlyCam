<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Fly Navigation - Three.js</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="m-0 overflow-hidden bg-gray-800">
    <div id="instructions" class="absolute top-2.5 left-2.5 text-white font-sans bg-black bg-opacity-50 p-2.5 rounded">
        Click to start navigation<br/>
        WASD: Move<br/>
        Shift: Speed Boost<br/>
        Mouse: Look<br/>
        ESC: Release Mouse
    </div>
    <div id="crosshair" class="absolute top-1/2 left-1/2 w-0.5 h-0.5 bg-white rounded-full transform -translate-x-1/2 -translate-y-1/2 pointer-events-none hidden"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- Configuration ---
        const config = {
            initialCameraDistance: 10,
            moveSpeed: { normal: 6.0, boost: 16.0 },
            mouseSensitivity: 0.002,
            verticalRotationLimit: Math.PI / 2 - 0.01
        };

        // --- Global Variables ---
        let scene, camera, renderer, pivot;
        const clock = new THREE.Clock();
        const movementState = { forward: 0, right: 0, shift: false };
        let pitch = 0, yaw = 0, isPointerLocked = false;
        const elements = {
            crosshair: document.getElementById('crosshair'),
            instructions: document.getElementById('instructions')
        };
        const vec = {
            direction: new THREE.Vector3(),
            right: new THREE.Vector3(),
            move: new THREE.Vector3(),
            worldUp: new THREE.Vector3(0, 1, 0)
        };

        // Create all mesh objects from configuration array
        function createObjects() {
            // Format: [geometry, color, position, optional rotation]
            const objects = [
                [new THREE.BoxGeometry(2, 2, 2), 0xff0000, [10, 1, 0]],
                [new THREE.SphereGeometry(1.5, 32, 16), 0x0000ff, [-8, 1.5, -5]],
                [new THREE.ConeGeometry(1.5, 3, 32), 0xffff00, [0, 1.5, -12]],
                [new THREE.BoxGeometry(20, 20, 20), 0x9370DB, [70, 10, -50]],
                [new THREE.TorusGeometry(15, 5, 16, 50), 0x00CED1, [-80, 20, -90], {x: Math.PI/2}],
                [new THREE.CylinderGeometry(10, 10, 30, 32), 0xFF8C00, [30, 15, -120]],
                [new THREE.ConeGeometry(15, 30, 4), 0x32CD32, [-40, 15, -150]]
            ];
            
            objects.forEach(([geometry, color, position, rotation]) => {
                const mesh = new THREE.Mesh(
                    geometry, 
                    new THREE.MeshStandardMaterial({ color })
                );
                mesh.position.set(...position);
                if (rotation) Object.entries(rotation).forEach(([axis, value]) => mesh.rotation[axis] = value);
                scene.add(mesh);
            });
        }
        
        // Initialize scene, camera, and renderer
        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x353ebd);
            scene.fog = new THREE.Fog(0x87ceeb, 1, 200);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);
            
            // Camera & pivot
            camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);
            pivot = new THREE.Object3D();
            scene.add(pivot);
            updateCameraPosition();
            
            // Lighting
            scene.add(
                new THREE.AmbientLight(0xffffff, 0.1),
                new THREE.DirectionalLight(0xffffff, 2.8)
            );
            
            // Add objects, setup events, start animation
            createObjects();
            setupEventListeners();
            requestAnimationFrame(animate);
        }
        
        // Setup all event listeners
        function setupEventListeners() {
            // Window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            // Key handlers - reuse the same patterns for down/up
            const keyMap = {
                'KeyW': ['forward', 1],
                'KeyS': ['forward', -1],
                'KeyA': ['right', -1],
                'KeyD': ['right', 1],
                'ShiftLeft': ['shift', true],
                'ShiftRight': ['shift', true]
            };
            
            document.addEventListener('keydown', (event) => {
                if (!isPointerLocked || !keyMap[event.code]) return;
                const [property, value] = keyMap[event.code];
                movementState[property] = value;
            });
            
            document.addEventListener('keyup', (event) => {
                if (!keyMap[event.code]) return;
                const [property, value] = keyMap[event.code];
                if (property === 'shift' || movementState[property] === value) {
                    movementState[property] = property === 'shift' ? false : 0;
                }
            });
            
            // Mouse and pointer lock
            document.addEventListener('mousemove', (event) => {
                if (!isPointerLocked) return;
                yaw -= (event.movementX || 0) * config.mouseSensitivity;
                pitch = THREE.MathUtils.clamp(
                    pitch - (event.movementY || 0) * config.mouseSensitivity,
                    -config.verticalRotationLimit,
                    config.verticalRotationLimit
                );
            });
            
            // Pointer lock events
            document.addEventListener('pointerlockchange', () => {
                isPointerLocked = document.pointerLockElement === renderer.domElement;
                elements.crosshair.style.display = isPointerLocked ? 'block' : 'none';
                elements.instructions.style.display = isPointerLocked ? 'none' : 'block';
                if (!isPointerLocked) Object.assign(movementState, {forward: 0, right: 0, shift: false});
            });
            
            renderer.domElement.addEventListener('click', () => {
                if (!isPointerLocked) renderer.domElement.requestPointerLock();
            });
        }
        
        // Update camera position based on pivot position and rotation
        function updateCameraPosition() {
            const quaternion = new THREE.Quaternion()
                .setFromAxisAngle(vec.worldUp, yaw)
                .multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), pitch));
            
            camera.position.copy(pivot.position)
                .add(new THREE.Vector3(0, 0, config.initialCameraDistance).applyQuaternion(quaternion));
            camera.quaternion.copy(quaternion);
        }
        
        // Update position based on movement state
        function update(deltaTime) {
            // Only calculate movement if needed
            if (movementState.forward || movementState.right) {
                // Get movement directions
                camera.getWorldDirection(vec.direction);
                vec.right.crossVectors(vec.worldUp, vec.direction).normalize();
                
                // Calculate movement vector
                vec.move.set(0, 0, 0);
                if (movementState.forward) vec.move.addScaledVector(vec.direction, movementState.forward);
                if (movementState.right) vec.move.addScaledVector(vec.right, -movementState.right);
                
                if (vec.move.lengthSq() > 0.001) vec.move.normalize();
                
                // Apply movement
                const speed = movementState.shift ? config.moveSpeed.boost : config.moveSpeed.normal;
                pivot.position.addScaledVector(vec.move, speed * deltaTime);
            }
            
            updateCameraPosition();
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            if (isPointerLocked) update(clock.getDelta());
            renderer.render(scene, camera);
        }
        
        // Start
        init();
    </script>
</body>
</html>