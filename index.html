<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Fly Navigation - Three.js</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="m-0 overflow-hidden bg-gray-800">
    <div id="instructions" class="absolute top-2.5 left-2.5 text-white font-sans bg-black bg-opacity-50 p-2.5 rounded">
        Click to start navigation<br/>
        WASD/Arrows: Move<br/>
        Shift: Speed Boost<br/>
        Mouse: Look<br/>
        ESC: Release Mouse
    </div>
    <div id="crosshair" class="absolute top-1/2 left-1/2 w-0.5 h-0.5 bg-white rounded-full transform -translate-x-1/2 -translate-y-1/2 pointer-events-none hidden"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- Configuration Constants ---
        const initialCameraDistance = 10;   // meters
        const normalMoveSpeed = 6.0;      // meters/second
        const boostMoveSpeed = 16.0;       // meters/second
        const mouseSensitivity = 0.002;   // radians/pixel delta
        const crosshairSize = 3;        // pixels (Reflected in CSS)
        const verticalRotationLimit = Math.PI / 2 - 0.01; // Radians (~ +/- 89.9 deg)

        // --- Global Variables ---
        let scene, camera, renderer, pivot;
        let clock = new THREE.Clock();

        // Movement State
        const movementState = {
            forward: 0, // -1 for backward, 1 for forward
            right: 0,   // -1 for left, 1 for right
            shift: false
        };

        // Rotation State
        let pitch = 0; // Vertical angle (relative to horizontal)
        let yaw = 0;   // Horizontal angle (around world Y axis)
        let isPointerLocked = false;

        const crosshairElement = document.getElementById('crosshair');
        const instructionsElement = document.getElementById('instructions');

        // Temporary vectors for calculations
        const tempCameraDirection = new THREE.Vector3();
        const tempRightDirection = new THREE.Vector3();
        const tempMoveVector = new THREE.Vector3();
        const worldUp = new THREE.Vector3(0, 1, 0);

        // --- Initialization ---
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x353ebd); 
            scene.fog = new THREE.Fog(0x87ceeb, 1, 200);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // Camera
            camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);

            // Pivot Point (using Object3D for easier management)
            pivot = new THREE.Object3D();
            pivot.position.set(0, 1.7, 0); // Start slightly above ground
            scene.add(pivot);

            // Set initial camera position relative to pivot based on initial pitch/yaw
            updateCameraPosition(); // Will calculate initial position based on pitch=0, yaw=0
            camera.lookAt(pivot.position); // Look at pivot initially

            // --- Scene Content ---
            // Simple Shapes
            const boxGeo = new THREE.BoxGeometry(2, 2, 2);
            const sphereGeo = new THREE.SphereGeometry(1.5, 32, 16);
            const coneGeo = new THREE.ConeGeometry(1.5, 3, 32);

            const mat1 = new THREE.MeshStandardMaterial({ color: 0xff0000 }); // Red
            const mat2 = new THREE.MeshStandardMaterial({ color: 0x0000ff }); // Blue
            const mat3 = new THREE.MeshStandardMaterial({ color: 0xffff00 }); // Yellow

            const box = new THREE.Mesh(boxGeo, mat1);
            box.position.set(10, 1, 0);
            scene.add(box);

            const sphere = new THREE.Mesh(sphereGeo, mat2);
            sphere.position.set(-8, 1.5, -5);
            scene.add(sphere);

            const cone = new THREE.Mesh(coneGeo, mat3);
            cone.position.set(0, 1.5, -12);
            scene.add(cone);

            // Distant Large Objects
            const giantCubeGeo = new THREE.BoxGeometry(20, 20, 20);
            const giantTorusGeo = new THREE.TorusGeometry(15, 5, 16, 50);
            const giantCylinderGeo = new THREE.CylinderGeometry(10, 10, 30, 32);
            const giantPyramidGeo = new THREE.ConeGeometry(15, 30, 4);
            
            const matGiant1 = new THREE.MeshStandardMaterial({ color: 0x9370DB }); // Purple
            const matGiant2 = new THREE.MeshStandardMaterial({ color: 0x00CED1 }); // Turquoise
            const matGiant3 = new THREE.MeshStandardMaterial({ color: 0xFF8C00 }); // Dark Orange
            const matGiant4 = new THREE.MeshStandardMaterial({ color: 0x32CD32 }); // Lime Green
            
            const giantCube = new THREE.Mesh(giantCubeGeo, matGiant1);
            giantCube.position.set(70, 10, -50);
            scene.add(giantCube);
            
            const giantTorus = new THREE.Mesh(giantTorusGeo, matGiant2);
            giantTorus.position.set(-80, 20, -90);
            giantTorus.rotation.x = Math.PI / 2;
            scene.add(giantTorus);
            
            const giantCylinder = new THREE.Mesh(giantCylinderGeo, matGiant3);
            giantCylinder.position.set(30, 15, -120);
            scene.add(giantCylinder);
            
            const giantPyramid = new THREE.Mesh(giantPyramidGeo, matGiant4);
            giantPyramid.position.set(-40, 15, -150);
            scene.add(giantPyramid);

            // --- Lighting ---
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 5);
            scene.add(directionalLight);

            // --- Event Listeners ---
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('pointerlockchange', onPointerLockChange);
            document.addEventListener('pointerlockerror', onPointerLockError);
            renderer.domElement.addEventListener('click', () => {
                if (!isPointerLocked) {
                    renderer.domElement.requestPointerLock();
                }
            });

            // Start Animation Loop
            animate();
        }

        // --- Event Handlers ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onKeyDown(event) {
            if (!isPointerLocked) return;
            switch (event.code) {
                case 'KeyW': case 'ArrowUp':    movementState.forward = 1; break;
                case 'KeyS': case 'ArrowDown':  movementState.forward = -1; break;
                case 'KeyA': case 'ArrowLeft':  movementState.right = -1; break;
                case 'KeyD': case 'ArrowRight': movementState.right = 1; break;
                case 'ShiftLeft': case 'ShiftRight': movementState.shift = true; break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': case 'ArrowUp':    if (movementState.forward === 1) movementState.forward = 0; break;
                case 'KeyS': case 'ArrowDown':  if (movementState.forward === -1) movementState.forward = 0; break;
                case 'KeyA': case 'ArrowLeft':  if (movementState.right === -1) movementState.right = 0; break;
                case 'KeyD': case 'ArrowRight': if (movementState.right === 1) movementState.right = 0; break;
                case 'ShiftLeft': case 'ShiftRight': movementState.shift = false; break;
            }
        }

        function onMouseMove(event) {
            if (!isPointerLocked) return;

            const deltaX = event.movementX || 0;
            const deltaY = event.movementY || 0;

            // Update Yaw (horizontal rotation)
            yaw -= deltaX * mouseSensitivity;

            // Update Pitch (vertical rotation) - Clamp vertical angle
            pitch -= deltaY * mouseSensitivity;
            pitch = Math.max(-verticalRotationLimit, Math.min(verticalRotationLimit, pitch));
        }

        function onPointerLockChange() {
            if (document.pointerLockElement === renderer.domElement) {
                isPointerLocked = true;
                crosshairElement.style.display = 'block';
                instructionsElement.style.display = 'none';
            } else {
                isPointerLocked = false;
                crosshairElement.style.display = 'none';
                instructionsElement.style.display = 'block';
                movementState.forward = 0;
                movementState.right = 0;
                movementState.shift = false;
            }
        }

        function onPointerLockError() {
            console.error('Pointer Lock failed.');
            isPointerLocked = false;
            crosshairElement.style.display = 'none';
            instructionsElement.style.display = 'block';
        }

        // --- Update Camera Position relative to Pivot ---
        function updateCameraPosition() {
            const offset = new THREE.Vector3(0, 0, initialCameraDistance);
            const quaternion = new THREE.Quaternion();
            const yawQuaternion = new THREE.Quaternion().setFromAxisAngle(worldUp, yaw);
            const pitchQuaternion = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), pitch);
            quaternion.multiplyQuaternions(yawQuaternion, pitchQuaternion);
            offset.applyQuaternion(quaternion);
            camera.position.copy(pivot.position).add(offset);
            camera.quaternion.copy(quaternion);
        }


        // --- Update Logic ---
        function update(deltaTime) {
            const currentSpeed = movementState.shift ? boostMoveSpeed : normalMoveSpeed;
            const moveDelta = currentSpeed * deltaTime;

            camera.getWorldDirection(tempCameraDirection);
            tempRightDirection.crossVectors(worldUp, tempCameraDirection).normalize();

            tempMoveVector.set(0, 0, 0);

            if (movementState.forward !== 0) {
                tempMoveVector.addScaledVector(tempCameraDirection, movementState.forward);
            }
            if (movementState.right !== 0) {
                tempMoveVector.addScaledVector(tempRightDirection, -movementState.right);
            }

             if (tempMoveVector.lengthSq() > 1e-6) {
                 tempMoveVector.normalize();
             }

            pivot.position.addScaledVector(tempMoveVector, moveDelta);
            updateCameraPosition();
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();
            if (isPointerLocked) {
                 update(deltaTime);
            }
            renderer.render(scene, camera);
        }

        // --- Start ---
        init();

    </script>
</body>
</html>