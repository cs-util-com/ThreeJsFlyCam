<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=width=device-width, initial-scale=1.0">
    <title>3D Fly Navigation - Three.js</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="m-0 overflow-hidden bg-gray-800">
    <div id="instructions" class="absolute top-2.5 left-2.5 text-white font-sans bg-black bg-opacity-50 p-2.5 rounded">
        Click to start navigation<br/>
        WASD: Move<br/>
        Shift: Speed Boost<br/>
        Mouse: Look<br/>
        ESC: Release Mouse<br/>
        Left-click: Place measurement point<br/>
        Enter: Complete current measurement
    </div>
    <div id="crosshair" class="absolute top-1/2 left-1/2 w-0.5 h-0.5 bg-white rounded-full transform -translate-x-1/2 -translate-y-1/2 pointer-events-none hidden"></div>
    
    <!-- Measurement Tool UI -->
    <div id="measurement-controls" class="absolute bottom-2.5 left-2.5 text-white font-sans flex gap-2">
        <button id="clearPoints" class="bg-red-600 hover:bg-red-700 px-3 py-1.5 rounded">Clear Reference Points</button>
        <button id="clearMeasurements" class="bg-red-600 hover:bg-red-700 px-3 py-1.5 rounded">Clear Measurements</button>
    </div>
    
    <div id="measurement-instructions" class="absolute top-2.5 right-2.5 text-white font-sans bg-black bg-opacity-50 p-2.5 rounded">
        <strong>Measurement Controls</strong><br/>
        Left-click: Place point<br/>
        Arrow keys: Snap to axis<br/>
        Backspace/Del: Remove last point<br/>
        Enter/R: Complete measurement<br/>
        Double-click label: Edit reference
    </div>

    <!-- File Upload Area for .spz and .ply files -->
    <div id="splats-dropzone" class="absolute top-20 left-2.5 bg-black bg-opacity-50 p-2.5 text-white rounded">
        <div class="text-center mb-2">Drag & drop or select files</div>
        <div class="flex flex-col items-center gap-2">
            <button id="select-file-btn" class="bg-blue-600 hover:bg-blue-700 px-3 py-1.5 rounded w-full">Select File</button>
            <input type="file" id="file-input" accept=".spz,.ply" class="hidden">
            <div class="text-xs italic">Supported: .spz, .ply files</div>
        </div>
        <div id="splatsError" class="text-red-400 hidden mt-2"></div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "gaussian-splats-3d": "https://cdn.jsdelivr.net/npm/@mkkellogg/gaussian-splats-3d@0.4.7/build/gaussian-splats-3d.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import * as GaussianSplats3D from 'gaussian-splats-3d';
        // --- Configuration ---
        const config = {
            initialCameraDistance: 5,
            minCameraDistance: 0.1,
            maxCameraDistance: 100,
            zoomSpeed: 0.9,
            moveSpeed: { normal: 6.0, boost: 16.0 },
            mouseSensitivity: 0.002,
            verticalRotationLimit: Math.PI / 2 - 0.01
        };

        // --- Global Variables ---
        let scene, camera, renderer, pivot;
        const clock = new THREE.Clock();
        const movementState = { forward: 0, right: 0, shift: false };
        let pitch = 0, yaw = 0, isPointerLocked = false;
        let cameraDistance = config.initialCameraDistance;
        const elements = {
            crosshair: document.getElementById('crosshair'),
            instructions: document.getElementById('instructions'),
            measurementInstructions: document.getElementById('measurement-instructions')
        };
        const vec = {
            direction: new THREE.Vector3(),
            right: new THREE.Vector3(),
            move: new THREE.Vector3(),
            worldUp: new THREE.Vector3(0, 1, 0)
        };

        // --- Measurement Tool Variables ---
        const measurementState = {
            active: true, // Always active
            measuring: false,
            points: [],
            previewPoint: new THREE.Vector3(),
            currentLine: null,
            snapAxis: null,
            globalScaleFactor: 1.0,
            lastClickTime: 0,
            currentColorIndex: 0,
            isLoop: false
        };
        
        // Pastel colors for measurement lines
        const lineColors = [
            0x98DDCA, // Soft Mint
            0xFFAEBC, // Pastel Pink
            0xFFD6A5, // Pastel Orange
            0xBBDEFB, // Soft Blue
            0xD0F0C0, // Tea Green
            0xF4C2C2, // Baby Pink
            0xCCCCFF, // Periwinkle
            0xF8C8DC, // Cotton Candy
            0xFDFD96, // Pastel Yellow
            0xBDECB6  // Soft Green
        ];
        
        const measurementObjects = {
            lines: [],
            points: [],
            labels: []
        };
        const raycaster = new THREE.Raycaster();
        // Set minimum distance to a very small value to detect nearby objects
        raycaster.near = 0.01;
        const centerScreen = new THREE.Vector2(0, 0); // Center of screen for raycasting
        let measurementGroup;

        let splatsLoaded = false;
        let splatViewer;

        function initSplatViewer() {
            if (splatsLoaded) return;
            splatsLoaded = true;
            splatViewer = new GaussianSplats3D.Viewer({
                cameraUp: [0, -1, -0.6],
                initialCameraPosition: [-1, -4, 6],
                initialCameraLookAt: [0, 4, 0]
            });
        }

        // Add a loading progress indicator
        function createProgressBar() {
            const progressContainer = document.createElement('div');
            progressContainer.className = 'fixed top-5 left-1/2 transform -translate-x-1/2 bg-black bg-opacity-70 p-3 rounded text-white z-50';
            progressContainer.id = 'loading-progress';
            
            const progressText = document.createElement('div');
            progressText.className = 'text-center mb-2';
            progressText.textContent = 'Loading...';
            
            const progressBarOuter = document.createElement('div');
            progressBarOuter.className = 'w-64 h-4 bg-gray-700 rounded overflow-hidden';
            
            const progressBarInner = document.createElement('div');
            progressBarInner.className = 'h-full bg-blue-500 transition-all duration-300 ease-out';
            progressBarInner.style.width = '0%';
            progressBarInner.id = 'progress-bar-inner';
            
            progressBarOuter.appendChild(progressBarInner);
            progressContainer.appendChild(progressText);
            progressContainer.appendChild(progressBarOuter);
            
            document.body.appendChild(progressContainer);
            progressContainer.style.display = 'none';
            
            return progressContainer;
        }

        const progressBar = createProgressBar();

        function updateProgressBar(percent) {
            const progressInner = document.getElementById('progress-bar-inner');
            if (progressInner) {
                progressInner.style.width = `${percent}%`;
            }
            if (percent >= 100) {
                setTimeout(() => {
                    progressBar.style.display = 'none';
                }, 500);
            } else if (progressBar.style.display === 'none') {
                progressBar.style.display = 'block';
            }
        }

        async function loadSplatFile(file) {
            try {
                const url = URL.createObjectURL(file);
                const fileName = file.name.toLowerCase();
                
                initSplatViewer();
                progressBar.style.display = 'block';
                updateProgressBar(0);
                
                if (fileName.endsWith('.spz')) {
                    // For SPZ files: Use the fetch API to get the binary data
                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    
                    const arrayBuffer = await response.arrayBuffer();
                    
                    // Create a scene with the binary data
                    await splatViewer.addSplatScene({
                        url, // Still include the URL for format detection
                        buffer: arrayBuffer, // Provide the raw buffer data
                        format: 'spz', // Explicitly specify SPZ format
                        position: [0, 1, 0],
                        rotation: [0, 0, 0, 1],
                        scale: [1, 1, 1],
                        onProgress: (progress) => {
                            console.log(`Loading progress: ${progress * 100}%`);
                            updateProgressBar(progress * 100);
                        }
                    });
                    
                    console.log('SPZ file loaded successfully and added to scene');
                } else if (fileName.endsWith('.ply')) {
                    // For PLY files, use standard approach
                    await splatViewer.addSplatScene({
                        url,
                        format: 'ply',
                        position: [0, 1, 0],
                        rotation: [0, 0, 0, 1],
                        scale: [1, 1, 1],
                        onProgress: (progress) => {
                            updateProgressBar(progress * 100);
                        }
                    });
                }
                
                splatViewer.start();
                updateProgressBar(100);
            } catch (err) {
                console.error('Error loading file:', err);
                showSplatError(`Failed to load file: ${err.message || 'Unknown error'}`);
                progressBar.style.display = 'none';
            }
        }

        function showSplatError(msg) {
            const errDiv = document.getElementById('splatsError');
            errDiv.innerText = msg;
            errDiv.classList.remove('hidden');
        }

        // Set up the file button click handler
        document.getElementById('select-file-btn').addEventListener('click', () => {
            document.getElementById('file-input').click();
        });

        // Handle file input selection
        document.getElementById('file-input').addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;
            
            document.getElementById('splatsError').classList.add('hidden');
            const name = file.name.toLowerCase();
            
            if (name.endsWith('.spz') || name.endsWith('.ply')) {
                loadSplatFile(file);
            } else {
                showSplatError('Unsupported file type. Please select a .spz or .ply file.');
            }
        });

        // Set up drag and drop handlers
        const dropzone = document.getElementById('splats-dropzone');
        dropzone.addEventListener('dragover', (event) => {
            event.preventDefault();
            dropzone.classList.add('bg-opacity-70');
        });
        
        dropzone.addEventListener('dragleave', () => {
            dropzone.classList.remove('bg-opacity-70');
        });
        
        dropzone.addEventListener('drop', (event) => {
            event.preventDefault();
            dropzone.classList.remove('bg-opacity-70');
            
            const file = event.dataTransfer.files[0];
            if (!file) return;
            
            document.getElementById('splatsError').classList.add('hidden');
            const name = file.name.toLowerCase();
            
            if (name.endsWith('.spz') || name.endsWith('.ply')) {
                loadSplatFile(file);
            } else {
                showSplatError('Unsupported file type. Please drop a .spz or .ply file.');
            }
        });

        // Create all mesh objects from configuration array
        function createObjects() {
            const objects = [
                [new THREE.BoxGeometry(2, 2, 2), 0xff0000, [10, 1, 0]],
                [new THREE.SphereGeometry(1.5, 32, 16), 0x0000ff, [-8, 1.5, -5]],
                [new THREE.ConeGeometry(1.5, 3, 32), 0xffff00, [0, 1.5, -12]],
                [new THREE.BoxGeometry(20, 20, 20), 0x9370DB, [70, 10, -50]],
                [new THREE.TorusGeometry(15, 5, 16, 50), 0x00CED1, [-80, 20, -90], {x: Math.PI/2}],
                [new THREE.CylinderGeometry(10, 10, 30, 32), 0xFF8C00, [30, 15, -120]],
                [new THREE.ConeGeometry(15, 30, 4), 0x32CD32, [-40, 15, -150]]
            ];
            
            objects.forEach(([geometry, color, position, rotation]) => {
                const mesh = new THREE.Mesh(
                    geometry, 
                    new THREE.MeshStandardMaterial({ color })
                );
                mesh.position.set(...position);
                if (rotation) Object.entries(rotation).forEach(([axis, value]) => mesh.rotation[axis] = value);
                scene.add(mesh);
            });
        }
        
        // Initialize scene, camera, and renderer
        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x353ebd);
            scene.fog = new THREE.Fog(0x87ceeb, 1, 200);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);
            
            // Camera & pivot
            camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);
            pivot = new THREE.Object3D();
            scene.add(pivot);
            updateCameraPosition();
            
            // Lighting
            scene.add(
                new THREE.AmbientLight(0xffffff, 0.1),
                new THREE.DirectionalLight(0xffffff, 2.8)
            );
            
            // Create measurement group
            measurementGroup = new THREE.Group();
            scene.add(measurementGroup);
            
            // Add objects, setup events, start animation
            createObjects();
            setupEventListeners();
            setupMeasurementTools();
            
            // Show measurement instructions by default
            elements.measurementInstructions.classList.remove('hidden');
            
            requestAnimationFrame(animate);
        }
        
        // Setup all event listeners
        function setupEventListeners() {
            // Window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            // Key handlers - reuse the same patterns for down/up
            const keyMap = {
                'KeyW': ['forward', 1],
                'KeyS': ['forward', -1],
                'KeyA': ['right', -1],
                'KeyD': ['right', 1],
                'ShiftLeft': ['shift', true],
                'ShiftRight': ['shift', true]
            };
            
            document.addEventListener('keydown', (event) => {
                if (!isPointerLocked) return;

                // Combine arrow key handling
                if (event.code.startsWith('Arrow')) {
                    switch (event.code) {
                        case 'ArrowUp':
                        case 'ArrowDown':
                            measurementState.snapAxis = 'y';
                            break;
                        case 'ArrowLeft':
                            measurementState.snapAxis = 'x';
                            break;
                        case 'ArrowRight':
                            measurementState.snapAxis = 'z';
                            break;
                    }
                    event.preventDefault();
                    return;
                }

                // Handle backspace/delete
                if (event.code === 'Backspace' || event.code === 'Delete') {
                    if (measurementState.points.length > 0) {
                        removeLastMeasurementPoint();
                    }
                    event.preventDefault();
                    return;
                }

                // Handle Enter
                if (event.code === 'Enter') {
                    if (measurementState.points.length > 0) {
                        if (measurementState.points.length >= 2) {
                            completeMeasurement();
                        } else {
                            cancelCurrentMeasurement();
                        }
                    }
                    event.preventDefault();
                    return;
                }

                // Movement keys
                if (!keyMap[event.code]) return;
                const [property, value] = keyMap[event.code];
                movementState[property] = value;
            });
            
            document.addEventListener('keyup', (event) => {
                if (!keyMap[event.code]) return;
                const [property, value] = keyMap[event.code];
                if (property === 'shift' || movementState[property] === value) {
                    movementState[property] = property === 'shift' ? false : 0;
                }
            });
            
            // Mouse and pointer lock
            document.addEventListener('mousemove', (event) => {
                if (!isPointerLocked) return;
                yaw -= (event.movementX || 0) * config.mouseSensitivity;
                pitch = THREE.MathUtils.clamp(
                    pitch - (event.movementY || 0) * config.mouseSensitivity,
                    -config.verticalRotationLimit,
                    config.verticalRotationLimit
                );
            });
            
            // Pointer lock events
            document.addEventListener('pointerlockchange', () => {
                isPointerLocked = document.pointerLockElement === renderer.domElement;
                elements.crosshair.style.display = isPointerLocked ? 'block' : 'none';
                elements.instructions.style.display = isPointerLocked ? 'none' : 'block';
                if (!isPointerLocked) Object.assign(movementState, {forward: 0, right: 0, shift: false});
            });
            
            // Detect real clicks vs. drags
            let dragStartTime = 0;
            let isDragging = false;
            
            renderer.domElement.addEventListener('mousedown', () => {
                dragStartTime = Date.now();
                isDragging = false;
            });
            
            renderer.domElement.addEventListener('mousemove', () => {
                if (Date.now() - dragStartTime > 100) {
                    isDragging = true;
                }
            });
            
            renderer.domElement.addEventListener('click', (event) => {
                if (!isPointerLocked) {
                    renderer.domElement.requestPointerLock();
                    return;
                }
                
                // Only handle real clicks, not drags
                if (!isDragging && Date.now() - measurementState.lastClickTime > 300) {
                    measurementState.lastClickTime = Date.now();
                    handleMeasurementClick();
                }
                
                isDragging = false;
            });

            // Mouse wheel for zoom
            renderer.domElement.addEventListener('wheel', (event) => {
                if (!isPointerLocked) return;
                
                event.preventDefault();
                
                // Determine scroll direction and amount
                const delta = Math.sign(event.deltaY) * config.zoomSpeed;
                
                // Update camera distance with limits
                cameraDistance = THREE.MathUtils.clamp(
                    cameraDistance + delta,
                    config.minCameraDistance,
                    config.maxCameraDistance
                );
                
                updateCameraPosition();
            }, { passive: false });
        }
        
        // Setup measurement tool UI and events
        function setupMeasurementTools() {
            // Button elements
            const clearPointsButton = document.getElementById('clearPoints');
            const clearMeasurementsButton = document.getElementById('clearMeasurements');
            
            // Clear all reference points
            clearPointsButton.addEventListener('click', () => {
                if (confirm('Are you sure you want to clear all reference points?')) {
                    clearReferencePoints();
                }
            });
            
            // Clear all measurements
            clearMeasurementsButton.addEventListener('click', () => {
                if (confirm('Are you sure you want to clear all measurements?')) {
                    clearAllMeasurements();
                }
            });
            
            // Initialize the first measurement
            startNewMeasurement();
        }
        
        // Handle click when in measurement mode
        function handleMeasurementClick() {
            if (!isPointerLocked) return;
            
            // Perform raycasting from center of screen (crosshair position)
            raycaster.setFromCamera(centerScreen, camera);
            
            // First check if we hit an existing reference point
            const existingPointIndex = checkHitReferencePoint();
            
            let position = null;
            
            if (existingPointIndex !== -1) {
                // Get the reference point position
                position = measurementObjects.points[existingPointIndex].position.clone();
            } else {
                // Check for intersections with all scene objects (excluding measurement objects)
                const sceneObjects = scene.children.filter(child => child !== measurementGroup);
                const intersects = raycaster.intersectObjects(sceneObjects, true);
                
                if (intersects.length > 0) {
                    // Use the first intersection point
                    position = intersects[0].point.clone();
                }
            }
            
            // If we have a position (either from reference point or scene object)
            if (position) {
                // Apply axis snapping if active and we have previous points
                if (measurementState.snapAxis && measurementState.points.length > 0) {
                    const lastPoint = measurementState.points[measurementState.points.length - 1];
                    if (measurementState.snapAxis === 'x') {
                        position.y = lastPoint.y;
                        position.z = lastPoint.z;
                    } else if (measurementState.snapAxis === 'y') {
                        position.x = lastPoint.x;
                        position.z = lastPoint.z;
                    } else if (measurementState.snapAxis === 'z') {
                        position.x = lastPoint.x;
                        position.y = lastPoint.y;
                    }
                }
                
                addMeasurementPoint(position);
            }
            
            // Reset snap axis after adding a point
            measurementState.snapAxis = null;
        }
        
        // Check if ray hits an existing reference point
        function checkHitReferencePoint() {
            // Use raycaster that's already set up with center screen position
            const intersects = raycaster.intersectObjects(measurementObjects.points, false);
            
            // Only return a hit if we directly intersect with a reference point
            if (intersects.length > 0) {
                return measurementObjects.points.indexOf(intersects[0].object);
            }
            
            return -1;
        }
        
        // Compute surface area of a closed loop
        function computeSurfaceArea(points) {
            // Simple Newell's method for polygon area in 3D:
            let normal = new THREE.Vector3();
            for (let i = 0; i < points.length; i++) {
                const current = points[i];
                const next = points[(i + 1) % points.length];
                normal.x += (current.y - next.y) * (current.z + next.z);
                normal.y += (current.z - next.z) * (current.x + next.x);
                normal.z += (current.x - next.x) * (current.y + next.y);
            }
            return 0.5 * normal.length();
        }

        // Handle loop closure
        function handleLoopClosed() {
            measurementState.isLoop = true;
            const area = computeSurfaceArea(measurementState.points);
            const center = new THREE.Vector3();
            measurementState.points.forEach(p => center.add(p));
            center.multiplyScalar(1 / measurementState.points.length);
            const areaLabel = createTextLabel(`Area: ${(area * measurementState.globalScaleFactor ** 2).toFixed(2)}`,
                center, measurementState.currentLineColor);
            measurementGroup.add(areaLabel);
            measurementObjects.labels.push(areaLabel);
            completeMeasurement();
        }

        // Add a new measurement point
        function addMeasurementPoint(position) {
            measurementState.points.push(position);

            const pointGeometry = new THREE.SphereGeometry(0.05, 8, 8);
            const pointMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const pointObject = new THREE.Mesh(pointGeometry, pointMaterial);
            pointObject.position.copy(position);
            pointObject.userData.isReferencePoint = true; // Tag as reference point
            measurementGroup.add(pointObject);
            measurementObjects.points.push(pointObject);

            if (measurementState.points.length >= 3) {
                const distToFirst = position.distanceTo(measurementState.points[0]);
                if (distToFirst < 0.01) {
                    position.copy(measurementState.points[0]);
                    handleLoopClosed();
                    return;
                }
            }

            if (measurementState.points.length > 1) {
                const lastTwoPoints = measurementState.points.slice(-2);
                createMeasurementSegment(lastTwoPoints[0], lastTwoPoints[1]);
            }

            updateMeasurementPreview();
        }
        
        // Create a measurement segment between two points
        function createMeasurementSegment(start, end) {
            const lineGeometry = new THREE.BufferGeometry().setFromPoints([start, end]);
            const lineColor = measurementState.currentLineColor;
            const lineMaterial = new THREE.LineBasicMaterial({ color: lineColor });
            const line = new THREE.Line(lineGeometry, lineMaterial);
            measurementGroup.add(line);
            
            const distance = start.distanceTo(end) * measurementState.globalScaleFactor;
            const midpoint = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
            const label = createTextLabel(distance.toFixed(2), midpoint, lineColor);
            label.userData.start = start.clone();
            label.userData.end = end.clone();
            label.userData.originalDistance = start.distanceTo(end);
            label.userData.lineColor = lineColor;
            measurementGroup.add(label);
            
            measurementState.currentLine = {
                line: line,
                labelObject: label,
                color: lineColor
            };
            
            label.userData.isLabel = true;
            label.userData.index = measurementObjects.labels.length;
            
            measurementObjects.lines.push(line);
            measurementObjects.labels.push(label);
            
            return line;
        }
        
        // Create text label for measurements
        function createTextLabel(text, position, color = 0xffffff) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            
            // Convert hex color to rgb for canvas
            const r = (color >> 16) & 255;
            const g = (color >> 8) & 255;
            const b = color & 255;
            
            // Darker background based on the color
            context.fillStyle = `rgba(${r * 0.7 | 0}, ${g * 0.7 | 0}, ${b * 0.7 | 0}, 0.8)`;
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            // Add a border using the line color
            context.strokeStyle = `rgb(${r}, ${g}, ${b})`;
            context.lineWidth = 4;
            context.strokeRect(2, 2, canvas.width - 4, canvas.height - 4);
            
            context.font = '24px Arial';
            context.fillStyle = 'white';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, canvas.width / 2, canvas.height / 2);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ 
                map: texture,
                depthTest: false,
                depthWrite: false,
            });
            const sprite = new THREE.Sprite(material);
            sprite.position.copy(position);
            sprite.scale.set(1.5, 0.4, 1);
            sprite.renderOrder = 999;  // Ensure labels render on top
            
            // Make sure these properties are set to enable raycasting
            sprite.userData.text = text;
            sprite.userData.color = color;
            sprite.userData.isInteractive = true;
            
            return sprite;
        }
        
        // Update label text
        function updateLabelText(label, text) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            
            const color = label.userData.color || 0xffffff;
            
            // Convert hex color to rgb for canvas
            const r = (color >> 16) & 255;
            const g = (color >> 8) & 255;
            const b = color & 255;
            
            // Darker background based on the color
            context.fillStyle = `rgba(${r * 0.7 | 0}, ${g * 0.7 | 0}, ${b * 0.7 | 0}, 0.8)`;
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            // Add a border using the line color
            context.strokeStyle = `rgb(${r}, ${g}, ${b})`;
            context.lineWidth = 4;
            context.strokeRect(2, 2, canvas.width - 4, canvas.height - 4);
            
            context.font = '24px Arial';
            context.fillStyle = 'white';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, canvas.width / 2, canvas.height / 2);
            
            label.material.map.dispose();
            label.material.map = new THREE.CanvasTexture(canvas);
            label.material.needsUpdate = true;
            
            label.userData.text = text;
        }
        
        // Update the measurement preview line
        function updateMeasurementPreview() {
            if (measurementState.points.length === 0) return;
            
            raycaster.setFromCamera(centerScreen, camera);
            
            // First try to hit actual scene objects (excluding measurement elements)
            const sceneObjects = scene.children.filter(child => child !== measurementGroup);
            let intersects = raycaster.intersectObjects(sceneObjects, true);
            
            // If no scene objects were hit, try to hit measurement points
            if (intersects.length === 0) {
                intersects = raycaster.intersectObjects(measurementObjects.points, false);
            }
            
            if (intersects.length > 0) {
                let previewPoint = intersects[0].point.clone();
                const lastPoint = measurementState.points[measurementState.points.length - 1];
                
                if (measurementState.snapAxis) {
                    if (measurementState.snapAxis === 'x') {
                        previewPoint.y = lastPoint.y;
                        previewPoint.z = lastPoint.z;
                    } else if (measurementState.snapAxis === 'y') {
                        previewPoint.x = lastPoint.x;
                        previewPoint.z = lastPoint.z;
                    } else if (measurementState.snapAxis === 'z') {
                        previewPoint.x = lastPoint.x;
                        previewPoint.y = lastPoint.y;
                    }
                }
                
                measurementState.previewPoint = previewPoint;
                
                const lineColor = measurementState.currentLineColor;
                
                if (!measurementState.previewLine) {
                    const lineGeometry = new THREE.BufferGeometry().setFromPoints([lastPoint, previewPoint]);
                    const lineMaterial = new THREE.LineDashedMaterial({ 
                        color: lineColor,
                        dashSize: 0.2,
                        gapSize: 0.1
                    });
                    measurementState.previewLine = new THREE.Line(lineGeometry, lineMaterial);
                    measurementState.previewLine.computeLineDistances();
                    measurementGroup.add(measurementState.previewLine);
                } else {
                    const points = [lastPoint, previewPoint];
                    measurementState.previewLine.geometry.dispose();
                    measurementState.previewLine.geometry = new THREE.BufferGeometry().setFromPoints(points);
                    measurementState.previewLine.computeLineDistances();
                }
                
                const distance = lastPoint.distanceTo(previewPoint) * measurementState.globalScaleFactor;
                const midpoint = new THREE.Vector3().addVectors(lastPoint, previewPoint).multiplyScalar(0.5);
                
                if (!measurementState.previewLabel) {
                    measurementState.previewLabel = createTextLabel(distance.toFixed(2), midpoint, lineColor);
                    measurementGroup.add(measurementState.previewLabel);
                } else {
                    updateLabelText(measurementState.previewLabel, distance.toFixed(2));
                    measurementState.previewLabel.position.copy(midpoint);
                }
            } else {
                // If no intersection, use camera direction to create a point at a reasonable distance
                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);
                
                const lastPoint = measurementState.points[measurementState.points.length - 1];
                const previewPoint = lastPoint.clone().add(direction.multiplyScalar(5));
                
                if (measurementState.snapAxis) {
                    if (measurementState.snapAxis === 'x') {
                        previewPoint.y = lastPoint.y;
                        previewPoint.z = lastPoint.z;
                    } else if (measurementState.snapAxis === 'y') {
                        previewPoint.x = lastPoint.x;
                        previewPoint.z = lastPoint.z;
                    } else if (measurementState.snapAxis === 'z') {
                        previewPoint.x = lastPoint.x;
                        previewPoint.y = lastPoint.y;
                    }
                }
                
                measurementState.previewPoint = previewPoint;
                
                const lineColor = measurementState.currentLineColor;
                
                if (!measurementState.previewLine) {
                    const lineGeometry = new THREE.BufferGeometry().setFromPoints([lastPoint, previewPoint]);
                    const lineMaterial = new THREE.LineDashedMaterial({ 
                        color: lineColor,
                        dashSize: 0.2,
                        gapSize: 0.1
                    });
                    measurementState.previewLine = new THREE.Line(lineGeometry, lineMaterial);
                    measurementState.previewLine.computeLineDistances();
                    measurementGroup.add(measurementState.previewLine);
                } else {
                    const points = [lastPoint, previewPoint];
                    measurementState.previewLine.geometry.dispose();
                    measurementState.previewLine.geometry = new THREE.BufferGeometry().setFromPoints(points);
                    measurementState.previewLine.computeLineDistances();
                }
                
                const distance = lastPoint.distanceTo(previewPoint) * measurementState.globalScaleFactor;
                const midpoint = new THREE.Vector3().addVectors(lastPoint, previewPoint).multiplyScalar(0.5);
                
                if (!measurementState.previewLabel) {
                    measurementState.previewLabel = createTextLabel(distance.toFixed(2), midpoint, lineColor);
                    measurementGroup.add(measurementState.previewLabel);
                } else {
                    updateLabelText(measurementState.previewLabel, distance.toFixed(2));
                    measurementState.previewLabel.position.copy(midpoint);
                }
            }
        }
        
        // Complete the current measurement
        function completeMeasurement() {
            if (measurementState.points.length < 2) {
                cancelCurrentMeasurement();
                return;
            }
            
            if (measurementState.previewLine) {
                measurementGroup.remove(measurementState.previewLine);
                measurementState.previewLine.geometry.dispose();
                measurementState.previewLine = null;
            }
            
            if (measurementState.previewLabel) {
                measurementGroup.remove(measurementState.previewLabel);
                measurementState.previewLabel.material.dispose();
                measurementState.previewLabel = null;
            }
            
            // Get current line color
            const lineColor = measurementState.currentLineColor;
            
            for (let i = 0; i < measurementState.points.length; i++) {
                const point = measurementState.points[i];
                const existingPoint = measurementObjects.points.find(p => 
                    p.position.distanceTo(point) < 0.001
                );
                
                if (!existingPoint) {
                    const pointGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                    const pointMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
                    const pointObject = new THREE.Mesh(pointGeometry, pointMaterial);
                    pointObject.position.copy(point);
                    pointObject.userData.isReferencePoint = true; // Tag as reference point
                    measurementGroup.add(pointObject);
                    measurementObjects.points.push(pointObject);
                }
            }
            
            if (measurementState.points.length > 2) {
                let totalDistance = 0;
                
                for (let i = 1; i < measurementState.points.length; i++) {
                    totalDistance += measurementState.points[i-1].distanceTo(measurementState.points[i]);
                }
                
                totalDistance *= measurementState.globalScaleFactor;
                
                const midIndex = Math.floor(measurementState.points.length / 2);
                const centerPosition = measurementState.points[midIndex].clone();
                centerPosition.y += 0.2;
                
                const totalLabel = createTextLabel(`Total: ${totalDistance.toFixed(2)}`, centerPosition, lineColor);
                totalLabel.userData.isTotal = true;
                totalLabel.userData.lineColor = lineColor;
                totalLabel.scale.set(1.5, 0.4, 1);
                measurementGroup.add(totalLabel);
                measurementObjects.labels.push(totalLabel);
            }
            
            if (measurementState.isLoop) {
                measurementState.isLoop = false;
            }

            measurementState.points = [];
            measurementState.measuring = false;
            
            startNewMeasurement();
        }
        
        // Remove the last point from the current measurement
        function removeLastMeasurementPoint() {
            if (measurementState.points.length <= 0) return;
            
            measurementState.points.pop();
            
            if (measurementState.currentLine && measurementState.points.length > 0) {
                measurementGroup.remove(measurementState.currentLine.line);
                measurementGroup.remove(measurementState.currentLine.labelObject);
                
                const lineIndex = measurementObjects.lines.indexOf(measurementState.currentLine.line);
                if (lineIndex !== -1) measurementObjects.lines.splice(lineIndex, 1);
                
                const labelIndex = measurementObjects.labels.indexOf(measurementState.currentLine.labelObject);
                if (labelIndex !== -1) measurementObjects.labels.splice(labelIndex, 1);
                
                measurementState.currentLine.line.geometry.dispose();
                measurementState.currentLine.labelObject.material.dispose();
                
                if (measurementState.points.length > 1) {
                    const prevPoints = measurementState.points.slice(-2);
                    measurementState.currentLine = {
                        line: measurementObjects.lines[measurementObjects.lines.length - 1],
                        labelObject: measurementObjects.labels[measurementObjects.labels.length - 1]
                    };
                } else {
                    measurementState.currentLine = null;
                }
            }
            
            updateMeasurementPreview();
        }
        
        // Start a new measurement
        function startNewMeasurement() {
            measurementState.measuring = true;
            measurementState.points = [];
            measurementState.previewPoint = new THREE.Vector3();
            measurementState.currentLine = null;
            measurementState.snapAxis = null;
            
            // Set a new color for this measurement line
            measurementState.currentLineColor = getNextLineColor();
            
            if (measurementState.previewLine) {
                measurementGroup.remove(measurementState.previewLine);
                measurementState.previewLine.geometry.dispose();
                measurementState.previewLine = null;
            }
            
            if (measurementState.previewLabel) {
                measurementGroup.remove(measurementState.previewLabel);
                measurementState.previewLabel.material.dispose();
                measurementState.previewLabel = null;
            }
        }
        
        // Cancel the current measurement
        function cancelCurrentMeasurement() {
            if (measurementState.previewLine) {
                measurementGroup.remove(measurementState.previewLine);
                measurementState.previewLine.geometry.dispose();
                measurementState.previewLine = null;
            }
            
            if (measurementState.previewLabel) {
                measurementGroup.remove(measurementState.previewLabel);
                measurementState.previewLabel.material.dispose();
                measurementState.previewLabel = null;
            }
            
            measurementState.measuring = false;
            measurementState.points = [];
            measurementState.currentLine = null;
            measurementState.snapAxis = null;
        }
        
        // Clear all reference points
        function clearReferencePoints() {
            // Clear reference points tracked in measurementObjects.points
            measurementObjects.points.forEach(point => {
                measurementGroup.remove(point);
                point.geometry.dispose();
                point.material.dispose();
            });
            
            // Find and clear all sphere meshes in measurementGroup that might be reference points
            measurementGroup.children.slice().forEach(child => {
                if (child.userData.isReferencePoint || 
                    (child.isMesh && child.geometry.type === 'SphereGeometry' && 
                     child.material.color.getHex() === 0xffffff)) {
                    measurementGroup.remove(child);
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                }
            });
            
            // Reset the array
            measurementObjects.points = [];
            
            // If we're currently measuring, restart the measurement to prevent errors
            if (measurementState.points.length > 0) {
                cancelCurrentMeasurement();
                startNewMeasurement();
            }
        }
        
        // Clear all measurements
        function clearAllMeasurements() {
            measurementObjects.lines.forEach(line => {
                measurementGroup.remove(line);
                line.geometry.dispose();
                line.material.dispose();
            });
            
            measurementObjects.labels.forEach(label => {
                measurementGroup.remove(label);
                label.material.dispose();
            });
            
            measurementObjects.lines = [];
            measurementObjects.labels = [];
            
            cancelCurrentMeasurement();
        }
        
        // Handle double-click on labels for editing
        document.addEventListener('dblclick', (event) => {
            // Calculate mouse position for raycasting
            const mouse = new THREE.Vector2(
                (event.clientX / window.innerWidth) * 2 - 1,
                -(event.clientY / window.innerHeight) * 2 + 1
            );
            
            // Setup raycaster
            raycaster.setFromCamera(mouse, camera);
            
            // Check for intersections with all measurement labels
            const intersects = raycaster.intersectObjects(measurementObjects.labels);
            
            if (intersects.length > 0) {
                const label = intersects[0].object;
                
                // Skip total labels
                if (label.userData.isTotal) return;
                
                // Release pointer lock if we're in locked mode
                if (isPointerLocked) {
                    document.exitPointerLock();
                    
                    // Store label for editing after pointer is released
                    setTimeout(() => {
                        promptForLabelEdit(label);
                    }, 100);
                } else {
                    promptForLabelEdit(label);
                }
            }
        });

        // Handle label editing in a separate function
        function promptForLabelEdit(label) {
            const newValue = prompt('Enter reference measurement value:', label.userData.text);
            
            if (newValue !== null && !isNaN(parseFloat(newValue))) {
                const originalDistance = label.userData.originalDistance;
                measurementState.globalScaleFactor = parseFloat(newValue) / originalDistance;
                
                updateAllMeasurementLabels();
            }
        }

        // Support direct click on measurements with pointer lock
        document.addEventListener('click', (event) => {
            if (!isPointerLocked) {
                const mouse = new THREE.Vector2(
                    (event.clientX / window.innerWidth) * 2 - 1,
                    -(event.clientY / window.innerHeight) * 2 + 1
                );
                
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(measurementObjects.labels);
                
                if (intersects.length > 0) {
                    // This helps prevent double-click and single-click conflicts
                    event.stopPropagation();
                }
            }
        });
        
        // Update all measurement labels with the current scale factor
        function updateAllMeasurementLabels() {
            measurementObjects.labels.forEach(label => {
                if (label.userData.isTotal) {
                    return;
                }
                
                if (label.userData.start && label.userData.end) {
                    const distance = label.userData.originalDistance * measurementState.globalScaleFactor;
                    updateLabelText(label, distance.toFixed(2));
                }
            });
            
            const totalLabels = measurementObjects.labels.filter(l => l.userData.isTotal);
            
            const processedLines = new Set();
            const measurementGroups = [];
            
            for (let i = 0; i < measurementObjects.lines.length; i++) {
                if (processedLines.has(i)) continue;
                
                const group = [];
                const queue = [i];
                
                while (queue.length > 0) {
                    const lineIndex = queue.shift();
                    if (processedLines.has(lineIndex)) continue;
                    
                    processedLines.add(lineIndex);
                    const line = measurementObjects.lines[lineIndex];
                    group.push(line);
                    
                    for (let j = 0; j < measurementObjects.lines.length; j++) {
                        if (processedLines.has(j)) continue;
                        
                        const otherLine = measurementObjects.lines[j];
                        const connected = linesAreConnected(line, otherLine);
                        
                        if (connected) queue.push(j);
                    }
                }
                
                if (group.length > 0) measurementGroups.push(group);
            }
            
            totalLabels.forEach((totalLabel, index) => {
                if (index < measurementGroups.length) {
                    const lines = measurementGroups[index];
                    let totalDistance = 0;
                    
                    lines.forEach(line => {
                        const pos = line.geometry.attributes.position.array;
                        const start = new THREE.Vector3(pos[0], pos[1], pos[2]);
                        const end = new THREE.Vector3(pos[3], pos[4], pos[5]);
                        totalDistance += start.distanceTo(end);
                    });
                    
                    totalDistance *= measurementState.globalScaleFactor;
                    updateLabelText(totalLabel, `Total: ${totalDistance.toFixed(2)}`);
                }
            });
        }
        
        // Check if two lines are connected (share a vertex)
        function linesAreConnected(line1, line2) {
            const pos1 = line1.geometry.attributes.position.array;
            const pos2 = line2.geometry.attributes.position.array;
            
            const line1Start = new THREE.Vector3(pos1[0], pos1[1], pos1[2]);
            const line1End = new THREE.Vector3(pos1[3], pos1[4], pos1[5]);
            const line2Start = new THREE.Vector3(pos2[0], pos2[1], pos2[2]);
            const line2End = new THREE.Vector3(pos2[3], pos2[4], pos2[5]);
            
            const threshold = 0.001;
            
            return (
                line1Start.distanceToSquared(line2Start) < threshold ||
                line1Start.distanceToSquared(line2End) < threshold ||
                line1End.distanceToSquared(line2Start) < threshold ||
                line1End.distanceToSquared(line2End) < threshold
            );
        }
        
        // Get the next color from the palette
        function getNextLineColor() {
            const color = lineColors[measurementState.currentColorIndex];
            measurementState.currentColorIndex = (measurementState.currentColorIndex + 1) % lineColors.length;
            return color;
        }
        
        // Update camera position based on pivot position and rotation
        function updateCameraPosition() {
            const quaternion = new THREE.Quaternion()
                .setFromAxisAngle(vec.worldUp, yaw)
                .multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), pitch));
            
            camera.position.copy(pivot.position)
                .add(new THREE.Vector3(0, 0, cameraDistance).applyQuaternion(quaternion));
            camera.quaternion.copy(quaternion);
        }
        
        // Update position based on movement state
        function update(deltaTime) {
            if (movementState.forward || movementState.right) {
                camera.getWorldDirection(vec.direction);
                vec.right.crossVectors(vec.worldUp, vec.direction).normalize();
                
                vec.move.set(0, 0, 0);
                if (movementState.forward) vec.move.addScaledVector(vec.direction, movementState.forward);
                if (movementState.right) vec.move.addScaledVector(vec.right, -movementState.right);
                
                if (vec.move.lengthSq() > 0.001) vec.move.normalize();
                
                const speed = movementState.shift ? config.moveSpeed.boost : config.moveSpeed.normal;
                pivot.position.addScaledVector(vec.move, speed * deltaTime);
            }
            
            updateCameraPosition();
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            if (isPointerLocked) update(clock.getDelta());
            
            if (measurementState.points.length > 0) {
                updateMeasurementPreview();
            }
            
            // Make sure labels face the camera for better interaction
            measurementObjects.labels.forEach(label => {
                label.lookAt(camera.position);
            });
            
            renderer.render(scene, camera);
        }
        
        // Start
        init();
    </script>
</body>
</html>